#!/usr/bin/env python3
"""
Plot local vs cross NUMA comparison (TPS and P99 latency) from
oltp_rw_local_numa_cross.csv.
"""

import argparse
import csv
import re
import statistics
import sys
from pathlib import Path
from typing import Optional

try:
    import matplotlib.pyplot as plt
except ImportError as exc:  # pragma: no cover
    sys.stderr.write("matplotlib is required. Install with: pip install matplotlib\n")
    raise


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Plot local vs cross NUMA comparison for oltp_read_write (TPS/P99)."
    )
    parser.add_argument(
        "--csv",
        default="sysbench_results/oltp_rw_local_numa_cross.csv",
        help="CSV file generated by run_sysbench_oltp_rw_local_numa_cross.sh",
    )
    parser.add_argument(
        "--output",
        default="sysbench_results/oltp_rw_local_numa_cross_compare.png",
        help="Output image path (PNG)",
    )
    return parser.parse_args()


def classify_row(row: dict) -> Optional[str]:
    cpu = (row.get("mysql_cpu_node") or "").strip()
    mem = (row.get("mysql_mem_node") or "").strip()
    if cpu and mem:
        return "local" if cpu == mem else "cross"

    profile = (row.get("numa_profile") or "").strip()
    match = re.match(r"^node(\d+)_mem(\d+)$", profile)
    if match:
        return "local" if match.group(1) == match.group(2) else "cross"
    return None


def load_data(csv_path: Path):
    if not csv_path.exists():
        sys.stderr.write(f"CSV not found: {csv_path}\n")
        sys.exit(1)

    data = {"local": {"tps": [], "p99": []}, "cross": {"tps": [], "p99": []}}
    with csv_path.open(newline="") as f:
        reader = csv.DictReader(f)
        required = {"status", "tps", "p99_latency_ms"}
        missing = required - set(reader.fieldnames or [])
        if missing:
            sys.stderr.write(f"CSV missing columns: {', '.join(sorted(missing))}\n")
            sys.exit(1)

        for row in reader:
            if row.get("status") != "ok":
                continue
            bucket = classify_row(row)
            if not bucket:
                continue
            try:
                tps = float(row["tps"])
                p99 = float(row["p99_latency_ms"])
            except (TypeError, ValueError):
                continue
            data[bucket]["tps"].append(tps)
            data[bucket]["p99"].append(p99)

    if not (data["local"]["tps"] or data["cross"]["tps"]):
        sys.stderr.write("No usable rows (need status=ok with numeric TPS/P99).\n")
        sys.exit(1)

    return data


def stats(values):
    mean = statistics.mean(values)
    std = statistics.stdev(values) if len(values) > 1 else 0.0
    return mean, std


def plot(data, output_path: Path):
    order = [k for k in ("local", "cross") if data[k]["tps"]]
    labels = [f"{k} (n={len(data[k]['tps'])})" for k in order]
    tps_means = [stats(data[k]["tps"])[0] for k in order]
    tps_err = [stats(data[k]["tps"])[1] for k in order]
    p99_means = [stats(data[k]["p99"])[0] for k in order]
    p99_err = [stats(data[k]["p99"])[1] for k in order]

    fig, axes = plt.subplots(1, 2, figsize=(10, 4))
    colors = ["#2ca02c" if k == "local" else "#d62728" for k in order]

    axes[0].bar(labels, tps_means, yerr=tps_err, color=colors, capsize=6)
    axes[0].set_ylabel("Transactions per second (TPS)")
    axes[0].set_title("TPS: local vs cross")
    axes[0].grid(axis="y", linestyle="--", alpha=0.4)

    axes[1].bar(labels, p99_means, yerr=p99_err, color=colors, capsize=6)
    axes[1].set_ylabel("P99 latency (ms)")
    axes[1].set_title("P99 latency: local vs cross")
    axes[1].grid(axis="y", linestyle="--", alpha=0.4)

    fig.suptitle("oltp_read_write NUMA comparison (local vs cross)")
    fig.tight_layout(rect=[0, 0, 1, 0.92])

    output_path.parent.mkdir(parents=True, exist_ok=True)
    fig.savefig(output_path, dpi=150)
    print(f"Saved plot: {output_path}")


def main():
    args = parse_args()
    data = load_data(Path(args.csv))
    plot(data, Path(args.output))


if __name__ == "__main__":
    main()
