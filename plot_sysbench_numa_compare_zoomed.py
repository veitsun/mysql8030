#!/usr/bin/env python3
"""
Plot a zoomed-in TPS/QPS comparison to highlight NUMA local vs cross-socket gaps.
This script keeps only the top portion of the y-axis so small differences are clearer
and annotates the absolute/percentage delta between the fastest and slowest runs.
"""

import argparse
import csv
import statistics
from pathlib import Path
import sys

try:
    import matplotlib.pyplot as plt
except ImportError as exc:  # pragma: no cover
    sys.stderr.write("matplotlib is required. Install with: pip install matplotlib\n")
    raise


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Plot a zoomed NUMA comparison (local vs cross-socket) with delta annotations."
    )
    parser.add_argument(
        "--csv",
        default="sysbench_results/oltp_rw_remote_numa_compare.csv",
        help="CSV file generated by run_sysbench_oltp_rw_remote_numa_compare.sh",
    )
    parser.add_argument(
        "--output",
        default="sysbench_results/oltp_rw_numa_compare_zoom.png",
        help="Output image path (PNG)",
    )
    parser.add_argument(
        "--pad-ratio",
        type=float,
        default=0.25,
        help="Extra headroom (as fraction of value span) to keep around bars for annotations.",
    )
    return parser.parse_args()


def load_data(csv_path: Path):
    if not csv_path.exists():
        sys.stderr.write(f"CSV not found: {csv_path}\n")
        sys.exit(1)

    data = {}
    order = []
    with csv_path.open(newline="") as f:
        reader = csv.DictReader(f)
        required = {"label", "tps", "qps", "status"}
        missing = required - set(reader.fieldnames or [])
        if missing:
            sys.stderr.write(f"CSV missing columns: {', '.join(sorted(missing))}\n")
            sys.exit(1)

        for row in reader:
            label = (row.get("label") or row.get("mysql_numa_profile") or "").strip()
            if not label:
                continue
            if row.get("status") != "ok":
                continue
            try:
                tps = float(row["tps"])
                qps = float(row["qps"])
            except (TypeError, ValueError):
                continue

            if label not in data:
                data[label] = {"tps": [], "qps": []}
                order.append(label)
            data[label]["tps"].append(tps)
            data[label]["qps"].append(qps)

    if not data:
        sys.stderr.write("No usable rows (need status=ok with numeric TPS/QPS).\n")
        sys.exit(1)

    return order, data


def aggregate(order, data):
    agg = {}
    for label in order:
        vals = data[label]

        def stats(values):
            mean = statistics.mean(values)
            std = statistics.stdev(values) if len(values) > 1 else 0.0
            return mean, std

        agg[label] = {
            "tps": stats(vals["tps"]),
            "qps": stats(vals["qps"]),
        }
    return agg


def calc_ylim(means, errs, pad_ratio):
    min_mean = min(means)
    max_mean = max(means)
    span = max(max_mean - min_mean, (max_mean or 1.0) * 0.01)
    pad = span * pad_ratio + (max(errs) if errs else 0) * 1.1
    lower = max(min_mean - pad, 0)
    upper = max_mean + pad
    return lower, upper


def annotate_gap(ax, labels, means, color="#d62728"):
    if len(means) < 2:
        return

    min_idx = min(range(len(means)), key=means.__getitem__)
    max_idx = max(range(len(means)), key=means.__getitem__)
    min_val, max_val = means[min_idx], means[max_idx]
    diff = max_val - min_val
    pct = diff / min_val * 100 if min_val else float("inf")

    ylim = ax.get_ylim()
    height = ylim[1] - ylim[0]
    y = ylim[1] - height * 0.15

    ax.annotate(
        "",
        xy=(max_idx, y),
        xytext=(min_idx, y),
        arrowprops=dict(arrowstyle="<->", color=color, lw=2.0),
    )
    ax.text(
        (min_idx + max_idx) / 2,
        y,
        f"Î” {diff:.2f} ({pct:+.2f}%)",
        ha="center",
        va="bottom",
        color=color,
        fontweight="bold",
        bbox=dict(boxstyle="round,pad=0.3", fc="white", ec=color, lw=0.8),
    )


def plot_zoomed(agg, order, output_path: Path, pad_ratio: float):
    labels = order
    tps_means = [agg[label]["tps"][0] for label in labels]
    tps_err = [agg[label]["tps"][1] for label in labels]
    qps_means = [agg[label]["qps"][0] for label in labels]
    qps_err = [agg[label]["qps"][1] for label in labels]

    fig, axes = plt.subplots(1, 2, figsize=(10, 4))
    palette = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728"]
    colors = [palette[i % len(palette)] for i in range(len(labels))]

    bars_tps = axes[0].bar(labels, tps_means, yerr=tps_err, color=colors, capsize=6)
    axes[0].set_ylabel("Transactions per second (TPS)")
    axes[0].set_title("oltp_read_write TPS (zoomed)")
    axes[0].grid(axis="y", linestyle="--", alpha=0.35)
    axes[0].set_ylim(*calc_ylim(tps_means, tps_err, pad_ratio))
    axes[0].bar_label(bars_tps, fmt="%.2f", padding=3, fontsize=9)
    annotate_gap(axes[0], labels, tps_means)

    bars_qps = axes[1].bar(labels, qps_means, yerr=qps_err, color=colors, capsize=6)
    axes[1].set_ylabel("Queries per second (QPS)")
    axes[1].set_title("oltp_read_write QPS (zoomed)")
    axes[1].grid(axis="y", linestyle="--", alpha=0.35)
    axes[1].set_ylim(*calc_ylim(qps_means, qps_err, pad_ratio))
    axes[1].bar_label(bars_qps, fmt="%.2f", padding=3, fontsize=9)
    annotate_gap(axes[1], labels, qps_means)

    fig.suptitle("MySQL NUMA (zoomed): local vs cross-socket delta highlighted")
    fig.tight_layout(rect=[0, 0, 1, 0.94])

    output_path.parent.mkdir(parents=True, exist_ok=True)
    fig.savefig(output_path, dpi=180)
    print(f"Saved zoomed plot: {output_path}")


def main():
    args = parse_args()
    order, data = load_data(Path(args.csv))
    agg = aggregate(order, data)
    plot_zoomed(agg, order, Path(args.output), args.pad_ratio)


if __name__ == "__main__":
    main()
