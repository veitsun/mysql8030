#!/usr/bin/env python3
"""
Plot TPS/QPS for MySQL NUMA local vs cross-socket runs.
Input: CSV produced by run_sysbench_oltp_rw_numa_compare.sh
"""

import argparse
import csv
import statistics
from pathlib import Path
import sys

try:
    import matplotlib.pyplot as plt
except ImportError as exc:  # pragma: no cover
    sys.stderr.write("matplotlib is required. Install with: pip install matplotlib\n")
    raise


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Plot sysbench NUMA comparison (local vs cross-socket).")
    parser.add_argument("--csv", default="sysbench_results/oltp_rw_numa_compare.csv",
                        help="CSV file generated by run_sysbench_oltp_rw_numa_compare.sh")
    parser.add_argument("--output", default="sysbench_results/oltp_rw_numa_compare.png",
                        help="Output image path (PNG)")
    return parser.parse_args()


def load_data(csv_path: Path):
    if not csv_path.exists():
        sys.stderr.write(f"CSV not found: {csv_path}\n")
        sys.exit(1)

    data = {}
    order = []
    with csv_path.open(newline="") as f:
        reader = csv.DictReader(f)
        required = {"label", "tps", "qps", "status"}
        missing = required - set(reader.fieldnames or [])
        if missing:
            sys.stderr.write(f"CSV missing columns: {', '.join(sorted(missing))}\n")
            sys.exit(1)

        for row in reader:
            label = (row.get("label") or row.get("mysql_numa_profile") or "").strip()
            if not label:
                continue
            if row.get("status") != "ok":
                continue
            try:
                tps = float(row["tps"])
                qps = float(row["qps"])
            except (TypeError, ValueError):
                continue

            if label not in data:
                data[label] = {"tps": [], "qps": []}
                order.append(label)
            data[label]["tps"].append(tps)
            data[label]["qps"].append(qps)

    if not data:
        sys.stderr.write("No usable rows (need status=ok with numeric TPS/QPS).\n")
        sys.exit(1)

    return order, data


def aggregate(order, data):
    agg = {}
    for label in order:
        vals = data[label]

        def stats(values):
            mean = statistics.mean(values)
            std = statistics.stdev(values) if len(values) > 1 else 0.0
            return mean, std

        agg[label] = {
            "tps": stats(vals["tps"]),
            "qps": stats(vals["qps"]),
        }
    return agg


def plot(agg, order, output_path: Path):
    labels = order
    tps_means = [agg[label]["tps"][0] for label in labels]
    tps_err = [agg[label]["tps"][1] for label in labels]
    qps_means = [agg[label]["qps"][0] for label in labels]
    qps_err = [agg[label]["qps"][1] for label in labels]

    fig, axes = plt.subplots(1, 2, figsize=(10, 4))
    palette = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728"]
    colors = [palette[i % len(palette)] for i in range(len(labels))]

    axes[0].bar(labels, tps_means, yerr=tps_err, color=colors, capsize=6)
    axes[0].set_ylabel("Transactions per second (TPS)")
    axes[0].set_title("oltp_read_write TPS")
    axes[0].grid(axis="y", linestyle="--", alpha=0.4)

    axes[1].bar(labels, qps_means, yerr=qps_err, color=colors, capsize=6)
    axes[1].set_ylabel("Queries per second (QPS)")
    axes[1].set_title("oltp_read_write QPS")
    axes[1].grid(axis="y", linestyle="--", alpha=0.4)

    fig.suptitle("MySQL NUMA: local vs cross-socket")
    fig.tight_layout(rect=[0, 0, 1, 0.95])

    output_path.parent.mkdir(parents=True, exist_ok=True)
    fig.savefig(output_path, dpi=150)
    print(f"Saved plot: {output_path}")


def main():
    args = parse_args()
    order, data = load_data(Path(args.csv))
    agg = aggregate(order, data)
    plot(agg, order, Path(args.output))


if __name__ == "__main__":
    main()
